from typing import Dict, Any, Optional, Union
from abc import ABC, abstractmethod

from analysis.owasp_llm_analyzer import PotentialIssue
from attacker.attack_target import AttackResult
from scanner.page_asset import SiteAsset, InputField, ApiCall


# 统一攻击接口 (AttackStrategy) 必须在引擎之前定义
class AttackStrategy(ABC):
    def __init__(self, llm_proxy: Any):
        self.llm = llm_proxy

    @abstractmethod
    def exploit(self, issue: PotentialIssue, site_asset: SiteAsset, session_context: Dict) -> AttackResult:
        """执行特定漏洞的攻击流程，接受 AttackTarget 作为输入。"""
        pass


# ==========================================================
# 攻击执行引擎 (ExploitationEngine)
# ==========================================================

class ExploitationEngine:
    """
    攻击执行引擎：负责根据漏洞类型路由到正确的 AttackStrategy 实现类。
    """

    # 策略映射表：将 OWASP 类别映射到攻击类的名称
    _ATTACK_MAPPING = {
        'A03: Injection': 'SQLiAttacker',
        'A03: Cross-Site Scripting (XSS)': 'XSSAttacker',  # XSS is often classified under A03 or its own category
        'SQLi': 'SQLiAttacker',
        'CommandInjection': 'CmdInjAttacker',
        # ... 其他 Top 10 漏洞 ...
    }

    def __init__(self, llm_proxy: Any, attacker_classes: Dict):
        """
        初始化引擎。

        参数:
            llm_proxy: LLM 代理对象。
            attacker_classes: 实际的攻击类字典 (e.g., { 'XSSAttacker': XSSAttacker })。
        """
        self.llm_proxy = llm_proxy
        self.attacker_classes = attacker_classes

    def _find_target_input(self, page_url: str, input_id: int, site_asset: SiteAsset) -> Optional[InputField]:
        """从 SiteAsset 中查找特定的 InputField。"""
        page_asset = site_asset.pages.get(page_url)
        if not page_asset:
            return None

        # 查找匹配 internal_id 的 InputField
        target_input = next(
            (i for i in page_asset.inputs if i.internal_id == input_id),
            None
        )
        return target_input

    def _find_target_api(self, target_url: str, site_asset: SiteAsset) -> Optional[ApiCall]:
        """从 SiteAsset 中查找特定的 ApiCall。"""
        # 优先查找独立 API
        for api in site_asset.discovered_apis:
            if api.url == target_url:
                return api

        # 其次查找页面观察到的 API
        for _, page in site_asset.pages.items():
            for api in page.api_calls:
                if api.url == target_url:
                    return api

        return None

    # def _get_attack_target_from_issue(self, issue: PotentialIssue, site_asset: SiteAsset) -> Optional[AttackTarget]:
    #     """
    #     根据 LLM 的 PotentialIssue，在 SiteAsset 中查找对应的攻击目标 (InputField 或 ApiCall)。
    #     """
    #
    #     # --- 场景 1: 关联到页面上的输入字段 (InputField) ---
    #     if issue.related_input_id is not None:
    #         # 假设 issue.location 格式是 "Page: /url -> Input: name"
    #         try:
    #             page_url = issue.location.split(" -> ")[0].replace("Page: ", "").strip()
    #         except:
    #             return None
    #
    #         return self._find_target_input(page_url, issue.related_input_id, site_asset)
    #
    #     # --- 场景 2: 关联到独立/页面 API (ApiCall) ---
    #     elif issue.related_api_url is not None:
    #         return self._find_target_api(issue.related_api_url, site_asset)
    #
    #     return None

    def run_attack(self, issue: PotentialIssue, site_asset: SiteAsset, potential_vuln_type: str, session_context: Dict) -> AttackResult:
        """
        执行特定漏洞的攻击流程。该方法通常由 run_attack_from_issue 调用。
        """
        # 1. 获取正确的攻击类名称
        attack_class_name = self._ATTACK_MAPPING.get(potential_vuln_type)

        if not attack_class_name or attack_class_name not in self.attacker_classes:
            return AttackResult(
                success=False,
                vulnerability_type=potential_vuln_type,
                proof_of_concept='',
                details=f"No dedicated attack strategy for type: {potential_vuln_type}"
            )

        try:
            # 2. 实例化对应的攻击策略 (Strategy)
            AttackerClass = self.attacker_classes[attack_class_name]
            attacker: AttackStrategy = AttackerClass(self.llm_proxy)

            # 3. 执行攻击
            result = attacker.exploit(issue, site_asset, session_context)
            return result

        except Exception as e:
            # 捕获执行过程中的异常（如网络错误、逻辑错误）
            return AttackResult(
                success=False,
                vulnerability_type=potential_vuln_type,
                proof_of_concept='',
                details=f"Attack execution failed for {potential_vuln_type} on target {issue.risk_reason}: {e}"
            )

    def run_attack_from_issue(self, issue: PotentialIssue, site_asset: SiteAsset,
                              session_context: Dict) -> AttackResult:
        """
        核心方法：从 LLM 的 Issue 开始，执行攻击，包括目标映射和路由。
        """

        # 路由并执行攻击
        return self.run_attack(
            issue=issue,
            site_asset=site_asset,
            potential_vuln_type=issue.owasp_category,
            session_context=session_context
        )